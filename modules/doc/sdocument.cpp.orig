#include "sdocument.h"


<<<<<<< HEAD
SDocument::SDocument(QCanvas* pCanvas)
=======
SDocument::SDocument(std::shared_ptr<QCanvas> pCanvas)
>>>>>>> Krista_Info_Err_Wnd
{
    if (!pCanvas)
        return;
    setCanvas(pCanvas);
    pCanvas.get()->setDocument(this);
    _initializeConnections();
}

<<<<<<< HEAD
SDocument::SDocument(QCanvas* pCanvas, const QString& path): SDocument(pCanvas)
=======
SDocument::SDocument(std::shared_ptr<QCanvas> pCanvas, const QString &path): SDocument(pCanvas)
>>>>>>> Krista_Info_Err_Wnd
{

}

SDocument::~SDocument()
{
    _disconnectCanvas();
}

void SDocument::onImageLoaded(SImage* pImage)
{
    Q_UNUSED(pImage);
    mpCanvas->setPaintTrigger(SObject::Loaded_Trigger);
    emit updateCanvas();
}

<<<<<<< HEAD
void SDocument::setCanvas(QCanvas* pCanvas)
=======
void SDocument::setCanvas(std::shared_ptr<QCanvas> pCanvas)
>>>>>>> Krista_Info_Err_Wnd
{
    _disconnectCanvas();
    this->mpCanvas = pCanvas;
}

SLayerManager& SDocument::getLayerManager()
{
    return mLayerMgr;
}

SFragLoader& SDocument::getFragLoader()
{
    return mFragLoader;
}

SCoordinate& SDocument::getCoordinate()
{
    return mCoordinate;
}

void SDocument::paint(QPainter& painter, const QRectF& viewArea, double scaleValue, SObject::PaintTrigger trigger)
{
    const layer_list layerList = mLayerMgr.getLayerList();

    //自底向上绘制图层
    std::list<SObject*>::const_iterator iter = layerList.begin();
    for (iter = layerList.begin(); iter != layerList.end(); ++iter)
    {
        SObject* obj = *iter;
        if (obj->isVisible())
            obj->paint(painter, true, viewArea, scaleValue, trigger);
    }

    //绘制选框
    //TODO::组合功能上线后重新调整逻辑
    //现在只单独绘制选框
    std::list<list_iterator> selectedLayerIterList = mLayerMgr.getSelectedLayerIterList();
    painter.setRenderHint(QPainter::Antialiasing);
    for (auto& iter : selectedLayerIterList)
        (*iter)->paintBoundRect(painter, scaleValue);

}

void SDocument::_initializeConnections()
{
    connect(&mFragLoader, &SFragLoader::imageLoaded, this, &SDocument::onImageLoaded);
    connect(this, &SDocument::updateCanvas, mpCanvas.get(), &QCanvas::doUpdate);
}

void SDocument::_disconnectCanvas()
{
<<<<<<< HEAD
    if (!mpCanvas)
        disconnect(this, &SDocument::updateCanvas, mpCanvas, &QCanvas::doUpdate);
=======
    if(!mpCanvas)
        disconnect(this, &SDocument::updateCanvas, mpCanvas.get(), &QCanvas::doUpdate);
>>>>>>> Krista_Info_Err_Wnd
}







